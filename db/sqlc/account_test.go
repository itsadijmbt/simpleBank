package db

import (
	"context"
	"database/sql"
	"testing"
	"time" // Needed for WithinDuration comparison in TestGetAccount

	"github.com/itsadijmbt/simple_bank/db/util" // Utilities for generating random test data
	"github.com/stretchr/testify/require"       // Assertion library for testing
)

// createRandomAccount is a helper function to generate a fully tested and valid Account object.
// This function doesn't start with "Test" so it won’t be run automatically by `go test`.
// Instead, it supports test functions by generating reliable test data for them.
func createRandomAccount(t *testing.T) Account {
	user := CreateRandomUser(t)

	// Prepare input parameters for account creation with random data
	//* user.Username otherwise it would case a refernce key err
	arg := CreateAccountParams{
		Owner:    user.Username,         // Random string representing account owner name
		Balance:  util.RandomMoney(),    // Random amount (float or int) for account balance
		Currency: util.RandomCurrency(), // Randomly chosen currency (e.g., USD, EUR)
	}

	//! Background: No deadline or cancellation needed for simple test
	// context.Background() is used here because we don’t need cancellation, deadlines, or values in this simple test scenario.
	account, err := testQueries.CreateAccount(context.Background(), arg)

	// Test should fail if any error occurs during account creation
	require.NoError(t, err, "CreateAccount failed")

	// Assert that account is not an empty struct after creation
	require.NotEmpty(t, account)

	// Validate that the returned account fields match the input values
	require.Equal(t, arg.Balance, account.Balance)
	require.Equal(t, arg.Owner, account.Owner)
	require.Equal(t, arg.Currency, account.Currency)

	// Check that the account has been assigned a valid ID and timestamp (autogenerated by DB)
	require.NotZero(t, account.ID)
	require.NotZero(t, account.CreatedAt)

	// Return the created account to be used in other test cases
	return account
}

// TestCreateAccount is a unit test for verifying that account creation works correctly
func TestCreateAccount(t *testing.T) {
	// & createRandomAccount is not a unit test itself; it creates a fully verified account
	// used for testing other DB queries. It encapsulates the logic of test data generation.
	createRandomAccount(t)
}

// TestGetAccount tests if we can successfully retrieve a previously created account by its ID
func TestGetAccount(t *testing.T) {
	// First create a new account to retrieve later
	account1 := createRandomAccount(t)

	// Retrieve the same account using its ID
	account2, err := testQueries.GetAccount(context.Background(), account1.ID)

	// Ensure the query did not return an error
	require.NoError(t, err)

	// Ensure the returned account is not empty
	require.NotEmpty(t, account2)

	// Validate that all fields match between the created and fetched account
	require.Equal(t, account1.ID, account2.ID)
	require.Equal(t, account1.Owner, account2.Owner)
	require.Equal(t, account1.Balance, account2.Balance)
	require.Equal(t, account1.Currency, account2.Currency)

	//! to check for same duration we use this
	// Timestamps may differ slightly due to formatting or precision, so use WithinDuration to compare
	require.WithinDuration(t, account1.CreatedAt, account2.CreatedAt, time.Second)
}

func TestUpdateAccount(t *testing.T) {

	account1 := createRandomAccount(t)

	arg := UpdateAccountParams{
		ID:      account1.ID,
		Balance: util.RandomMoney(),
	}

	account2, err := testQueries.UpdateAccount(context.Background(), arg)

	require.NoError(t, err)

	// Ensure the returned account is not empty
	require.NotEmpty(t, account2)

	// Validate that all fields match between the created and fetched account
	require.Equal(t, account1.ID, account2.ID)
	require.Equal(t, account1.Owner, account2.Owner)
	require.Equal(t, arg.Balance, account2.Balance)
	require.Equal(t, account1.Currency, account2.Currency)

	//! to check for same duration we use this
	// Timestamps may differ slightly due to formatting or precision, so use WithinDuration to compare
	require.WithinDuration(t, account1.CreatedAt, account2.CreatedAt, time.Second)

}

func TestDeleteAccount(t *testing.T) {
	// Step 1: Create an account to delete
	account1 := createRandomAccount(t)

	//* Step 2: Delete the created account
	err := testQueries.DeleteAccount(context.Background(), account1.ID)
	require.NoError(t, err) // deletion should succeed without error

	//* Step 3: Try fetching the account again — should return sql.ErrNoRows
	account2, err := testQueries.GetAccount(context.Background(), account1.ID)

	//^ You're testing cases where a database query should not return a row.
	require.EqualError(t, err, sql.ErrNoRows.Error()) // expected: account no longer exists

	//! DB query failed because nothing was found, not because of any other unexpected error
	require.Empty(t, account2) // the returned account struct should be empty
}

func TestListAccounts(t *testing.T) {
	// create 10 fresh accounts
	var lastAccount Account
	for i := 0; i < 10; i++ {
		lastAccount = createRandomAccount(t)
	}

	arg := ListAccountsParams{
		Owner:  lastAccount.Owner,
		Limit:  5, // ask for just the next 5
		Offset: 0, // after skipping the first 5
	}

	accounts, err := testQueries.ListAccounts(context.Background(), arg)
	require.NoError(t, err)
	require.NotEmpty(t, accounts)

	for _, account := range accounts {
		require.NotEmpty(t, account)
		require.Equal(t, lastAccount.Owner, account.Owner)
	}
}

//*-------------------------------------------------------example-------------------------------//
// & runInTx is a helper that runs any test logic inside a DB transaction
// * It takes the test object `t` and a function that runs test logic using a transactional Queries object

//!  func runInTx(t *testing.T, testFunc func(q *Queries)) {
//! 	Start a new SQL transaction
//! 	tx, err := testDB.BeginTx(context.Background(), nil)
//! 	require.NoError(t, err)

//! 	 Create a new SQLC Queries object scoped to this transaction
//! 	This means all queries will be run inside this tx — not committed to the DB
//! 	q := New(tx)

//! 	 Ensure we always rollback after the test finishes
// !	  Even if the test fails, rollback will discard all changes
//! 	defer tx.Rollback()

//! 	 Run the actual test logic, passing in the tx-scoped Queries object
//! 	testFunc(q)
//! }
